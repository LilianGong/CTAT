import("types.nools");

// Some production rules for the Mendel Abductive Reasoning Tutor


//--------------------------------------------------------------------------------------------
//
// Functions
//
function removeDuplicates(l) {
	var ret = [];
	if (!(l instanceof Array) || l.length === 0) {
		return l;
	}
	for (var i = 0; i < l.length; i++) {
		if (ret.indexOf(l[i]) < 0) {
			ret.push(l[i]);
		}
	}
	return ret;
}

//--------------------------------------------------------------------------------------------
//
// Initializing working memory
//
// This rule does not require further work from you.
//
//--------------------------------------------------------------------------------------------
rule bootstrap {
	when {
		b: Boolean b === true from true;
	}
	then {
		assert(new TPA("problemstatement", "UpdateTextArea", probtxt));
		assert(new TPA("strain1", "UpdateTextField", strain1.name));
		assert(new TPA("strain2", "UpdateTextField", strain2.name));
		assert(new TPA("strain3", "UpdateTextField", strain3.name));
	
		assert(new Strain(strain1.name, strain1.n, strain1.phenotype, "concPartStr1", "concFinalStr1"));
		assert(new Strain(strain2.name, strain2.n, strain2.phenotype, "concPartStr2", "concFinalStr2"));
		assert(new Strain(strain3.name, strain3.n, strain3.phenotype, "concPartStr3", "concFinalStr3"));
	
		assert(new Cross("cross1", cross1.strains, cross1.offspringExt, cross1.offspringInt));
		assert(new Cross("cross2", cross2.strains, cross2.offspringExt, cross2.offspringInt));
		assert(new Cross("cross3", cross3.strains, cross3.offspringExt, cross3.offspringInt));
		assert(new Cross("cross4", cross4.strains, cross4.offspringExt, cross4.offspringInt));
		assert(new Cross("cross5", cross5.strains, cross5.offspringExt, cross5.offspringInt));
		assert(new Cross("cross6", cross6.strains, cross6.offspringExt, cross6.offspringInt));
		
		var crossName, rowNames = [];
		for (var i = 1; i < 7; i++) {
			crossName = "Cr"+i;
			rowNames.push(crossName+"Row");
			assert(new interfaceElement(crossName+"Str1", null));
			assert(new interfaceElement(crossName+"Str2", null));
			assert(new interfaceElement(crossName+"Offspring", null));
			assert(new interfaceRow(crossName+"Row", [crossName+"Str1",crossName+"Str2"], crossName+"Offspring")); 
		}
		
		var intElPartName, intElFinalName;
		for (var i = 1; i < 4; i++) {
			intElPartName = "concPartStr"+i;
			intElFinalName = "concFinalStr"+i;
			assert(new interfaceElement(intElPartName, null));
			assert(new interfaceElement(intElFinalName, null));
		}
		
		assert(new Problem(probname, [strain1.name, strain2.name, strain3.name], rowNames));
	
		setProblemAttribute("use_backtracking", true);
		halt();
	}
}

//--------------------------------------------------------------------------------------------
//
// Rules for the selectCross subgoal
//
// Note: The rules for this subgoal are complete. You should not need more rules and you should
//		not need to change the current rules for this subgoal.
//
//--------------------------------------------------------------------------------------------

rule selectFirstStrain {
	when {
		prob: Problem prob.subgoal === "selectCross" && !prob.firstStrainCurCross && 
				prob.interfaceRows {interfaceRows: intRows};
		s: Strain {name: s1};
		exists(c: Cross s1 in c.strains);
		intRow: interfaceRow intRow.name === intRows[0] {iesStrains: intRowStrains};
		ie: interfaceElement !ie.value && ie.name in intRowStrains {name: selection};
	}
	then {
		if (checkSAI({selection: selection, action: "UpdateTextField", input: s1})) {
			modify(prob, "firstStrainCurCross", s1);
			modify(ie, "value", s1);
			halt();
		} else {
			backtrack();
		}
	}
}


rule selectSecondStrainDiff {
	when {
		prob: Problem prob.subgoal === "selectCross" && prob.firstStrainCurCross  && 
				prob.interfaceRows {interfaceRows: intRows, firstStrainCurCross: s1};
		str2: Strain str2.name !== s1 {name: s2};
		c: Cross s1 in c.strains && s2 in c.strains {offspringExt: o, strains: strains};
		r: interfaceRow r.name === intRows[0] {iesStrains: intRowStrains, ieResult: sel3};
		ie2: interfaceElement !ie2.value && ie2.name in intRowStrains {name: sel2};
		ie3: interfaceElement ie3.name === sel3;
	}
	then {
		if (checkSAI({selection: sel2, action: "UpdateTextField", input: s2})) {
			modify(ie2, "value", s2);
			assert(new TPA(sel3, "UpdateTextField", o));
			assert(new TPA(sel3, "lock", true));
			modify(prob, "firstStrainCurCross", null);
			modify(prob, "interfaceRows", intRows.slice(1));
			modify(prob, "curCross", c.name);
			modify(prob, "subgoal", "inferFromCross");
			//halt();     // highly unusual!
		} else {
			backtrack();
		}
	}
}


rule selectSecondStrainSame {
	when {
		prob: Problem prob.subgoal === "selectCross" && prob.firstStrainCurCross  && 
				prob.interfaceRows {interfaceRows: intRows, firstStrainCurCross: s1};
		c: Cross c.strains[0] === s1 && c.strains[1] === s1 {offspringExt: o};
		r: interfaceRow r.name === intRows[0] {iesStrains: intRowStrains, ieResult: sel3};
		ie2: interfaceElement !ie2.value && ie2.name in intRowStrains {name: sel2};
		ie3: interfaceElement ie3.name === sel3;
	}
	then {
		if (checkSAI({selection: sel2, action: "UpdateTextField", input: s1})) {
			modify(ie2, "value", s1);
			assert(new TPA(sel3, "UpdateTextField", o));
			assert(new TPA(sel3, "lock", true));
			modify(prob, "firstStrainCurCross", null);
			modify(prob, "interfaceRows", intRows.slice(1));
			modify(prob, "curCross", c.name);
			modify(prob, "subgoal", "inferFromCross");
			//halt();    // highly unusual!
		} else {
			backtrack();
		}
	}
}


//--------------------------------------------------------------------------------------------
//
// Rules for the inferFromCross subgoal
//
// You will need to write more rules for this subgoal.
//
//--------------------------------------------------------------------------------------------

// dummyInferFromCrossRule
// IF there is an inferFromCross subgoal
//	  AND c is the current Cross
//    AND    < other conditions regarding c>
// THEN
//    < make inferences just from the results of c>
//    AND remove c from prob's curCross slot
//    AND retract c from working memory
//    AND set the subgoal to makeInferences
//
rule dummyInferFromCrossRule {
    salience: -5;
	when {
		prob: Problem prob.subgoal === "inferFromCross" {curCross: cName};
		c: Cross c.name === cName ;
	}
	then {
		modify(prob, "curCross", null);
		retract(c);
		modify(prob, "subgoal", "makeInferences");
	}
}


//Rest of the inferFromCross Rules


// Rule inferFromS1xS1_100A in English
// IF 
//there is a goal to determine the gene type of S 
// And S1’s partial conclusion is not defined
// And S1’s final conclusion is not defined
// And the two strains are the identical plant
// And the cross for S1xS1 result is equal to 100 percent of phenotype A
// THEN
// Write S1’s partial conclusion as Homozygous
rule inferFromS1xS1_100A{
 	when {
 		prob: Problem prob.subgoal === "inferFromCross" {curCross: cName};
 		c: Cross c.name === cName && c.offspringInt[0] === 100;
 		s1: Strain s1.name === c.strains[0] && s1.name === c.strains[1] && s1.finalConclusion=="" {phenotype: p, partialConclusions: pC, finalConclusion: fC};
 		//&& s1.name === c.strains[1] && s1.partialConclusions==[] && s1.finalConclusion=="" 
 	}
 	then {
 	    console.log("inferFromS1xS1_100A MATCHED!!!");
 	    if(!(pC.includes("homozygous"))) {
 	        pC.push("homozygous");
 	        modify(s1, "partialConclusions", pC);
 	        console.log(pC + " inserted!");
 		}
 	}
 }



// Rule inferFromS1xS2_100A in English (no inference)
// ***** as it makes no inference, we don't have to write it down as rule *****
// IF there is a goal to determine the gene type of S 
// And S1’s partial conclusion is not defined
// And S1’s final conclusion is not defined
// And S2’s partial conclusion is not defined
// And S2’s final conclusion is not defined
// And the cross for S1xS2 result is equal to 100 percent of phenotype A
// THEN
// We cannot draw any conclusion
// Do not change anything to the working memory


 
// Rule inferFromS1xS3_100B in English
// IF 
//there is a goal to determine the gene type of S 
// And S1’s partial conclusion is not defined
// And S1’s final conclusion is not defined
// And S3’s partial conclusion is not defined
// And S3’s final conclusion is not defined
// And the phenotype of S1 is different from the phenotype of S3
// And the cross for S1xS3 result is equal to 100 percent of phenotype B
// THEN
// Write S1’s final conclusion as Homozygous Recessive
// Write S3’s final conclusion as Homozygous Dominant

 rule inferFromS1xS3_100B{
 	when {
 		prob: Problem prob.subgoal === "inferFromCross" {curCross: cName};
 		c: Cross c.name === cName && c.offspringInt[0] === 100 {offspringInt: off, strains: s};
 		s1: Strain s.includes(s1.name)  && s1.finalConclusion=="" && off.includes(s1.phenotype);
 		s3: Strain s.includes(s3.name) && s1.phenotype != s3.phenotype  && s3.finalConclusion=="";
 		//s1: Strain s1.name in c.strains && s1.partialConclusions=="" && s1.finalConclusion=="" && c.offspringInt[1] === s1.name;
 	}
 	then {
 	    modify(s1, "finalConclusion", "homozygous dominant");
 	    modify(s1, "finalConclusionWritten", false);
 	    modify(s3, "finalConclusion", "homozygous recessive");
 	    modify(s3, "finalConclusionWritten", false);
 	}
 }


// Rule inferFromS1xS2_75A in English
// IF 
//there is a goal to determine the gene type of S 
// And S1’s partial conclusion is not defined
// And S1’s final conclusion is not defined
// And S2’s partial conclusion is not defined
// And S2’s final conclusion is not defined
// And the phenotype of S1 is the same as the phenotype of S2
// And the cross for S1xS2 result is equal to 75 percent of phenotype A, and 25 percent of phenotype B
// THEN
// Write S1’s final conclusion as Heterozygous
// Write S2’s final conclusion as Heterozygous

rule inferFromS1xS2_75A{
	when {
 		prob: Problem prob.subgoal === "inferFromCross" {curCross: cName};
 		c: Cross c.name === cName && c.offspringInt[2] === 75 {offspringInt: off, strains: s};
 		s1: Strain s.includes(s1.name)  && s1.finalConclusion=="";
 		s2: Strain s.includes(s2.name)  && s2.finalConclusion=="";
 		//s1: Strain s1.name in c.strains && s1.partialConclusions=="" && s1.finalConclusion=="" && c.offspringInt[1] === s1.name;
 	}
 	then {
 	    modify(s1, "finalConclusion", "heterozygous");
 	    modify(s1, "finalConclusionWritten", false);
 	    modify(s2, "finalConclusion", "heterozygous");
 	    modify(s2, "finalConclusionWritten", false);
 	}

}

// Rule inferFromS1xS1_75A in English
// ***** as it can be fired as inferFromS1xS2_75A so we don't need to write down this one *****
// IF there is a goal to determine the gene type of S 
// And S1’s partial conclusion is not defined
// And S1’s final conclusion is not defined
// And the two strains are the identical plant
// And the cross for S1xS1 result is equal to 75 percent of phenotype A, and 25 percent of phenotype B
// THEN
// Write S1’s final conclusion as Heterozygous


// Rule inferFromS1xS3_50B in English
// IF there is a goal to determine the gene type of S 
// And S1’s partial conclusion is not defined
// And S1’s final conclusion is not defined
// And S3’s partial conclusion is not defined
// And S3’s final conclusion is not defined
// And the phenotype of S1 is different from the phenotype of S3
// And the cross for S1xS3 result is equal to 50 percent of phenotype A, and 50 percent of phenotype B
// THEN
// Write S1’s partial conclusion as “Heterozygous or Homozygous recessive”
// Write S3’s partial conclusion as “Heterozygous or Homozygous recessive”

rule inferFromS1xS3_50B{
	when {
 		prob: Problem prob.subgoal === "inferFromCross" {curCross: cName};
 		c: Cross c.name === cName && c.offspringInt[0] === 50 {offspringInt: off, strains: s};
 		s1: Strain s.includes(s1.name)   {partialConclusions: pC1};
 		s3: Strain s.includes(s3.name)  && s1.phenotype != s3.phenotype {partialConclusions: pC3};
 		
 	}
 	then {
 	    console.log("inferFromS1xS3_50B MATCHED!!!");
 	    if(!(pC1.includes("homozygous recessive or heterozygous"))) {
 	        pC1.push("homozygous recessive or heterozygous");
 	        modify(s1, "partialConclusions", pC1);
 	        console.log(pC1 + " inserted!");
 	    }
 	    if(!(pC3.includes("homozygous recessive or heterozygous"))) {
 	        pC3.push("homozygous recessive or heterozygous");
 	        modify(s3, "partialConclusions", pC3);
 	        console.log(pC3 + " inserted!");
 		}
 	}
}
 

//--------------------------------------------------------------------------------------------
//
// Rules for the makeInferences subgoal
//
// You will need to write more rules for this subgoal,  based on your cognitive task analysis.
//
//--------------------------------------------------------------------------------------------


// Rule makeInferenceFromS1xS2_HR in English
// IF 
//there is a goal to determine the gene type of S 
// And S1’s final conclusion is Homozygous Recessive
// And the phenotype of S1 is the same as the phenotype of S2
// THEN
// Write S2’s final conclusion as Homozygous Recessive

rule makeInferenceFromS1xS2_HR{
    when{
        prob: Problem prob.subgoal==="makeInferences";
        s1: Strain s1.finalConclusion==="homozygous recessive" {phenotype:p};
        s2: Strain s2.finalConclusion=="" && s2.phenotype===p;
    }
    then{
        modify(s2, "finalConclusion", "homozygous recessive");
    }
}


//Rule makeInferenceFromS1xS3_HR in English
// IF 
// there is a goal to determine the gene type of S 
// And S1’s final conclusion is Heterozygous or Homozygous Dominant
// And the phenotype of S1 is the different from the phenotype of S3
// THEN
// Write S3’s final conclusion as Homozygous Recessive

rule makeInferenceFromS1xS3_HR{
    when{
        prob: Problem prob.subgoal==="makeInferences";
        s1: Strain s1.finalConclusion==="heterozygous" || s1.finalConclusion==="homozygous dominant" {phenotype:p};
        s3: Strain s3.finalConclusion=="" && s3.phenotype!== p;
    }
    then{
        modify(s3, "finalConclusion", "homozygous recessive");
    }
}
//Rule makeInferenceFromS1xS2_HET in English
// IF 
//there is a goal to determine the gene type of S 
// And S1’s final conclusion is Heterozygous or Homozygous Dominant
// And the phenotype of S1 is the same as the phenotype of S2
// And S2’s partial conclusion is “Heterozygous or Homozygous recessive”
// THEN
// Write S2’s final conclusion as Heterozygous

rule makeInferenceFromS1xS2_HET{
    when{
        prob: Problem prob.subgoal==="makeInferences";
        s1: Strain s1.finalConclusion==="heterozygous" || s1.finalConclusion==="homozygous dominant" {phenotype:p};
        s2: Strain s2.finalConclusion == "" && s2.phenotype == p && s2.partialConclusions.includes("homozygous recessive or heterozygous");
    }
    then{
        modify(s2, "finalConclusion", "heterozygous");
    }
}
// Rule makeInferenceFromS1xS2_same_HD in English
// inferFromS1xS2_part_HD
// IF there is a goal to determine the gene type of S 
// And S1’s final conclusion is Heterozygous or Homozygous Dominant
// And the phenotype of S1 is the same as the phenotype of S2
// And S2’s partial conclusion is “Homozygous”
// THEN
// Write S2’s final conclusion as Homozygous Dominant

rule makeInferenceFromS1xS2_same_HD{
    when{
        prob: Problem prob.subgoal==="makeInferences";
        s1: Strain s1.finalConclusion==="heterozygous" || s1.finalConclusion==="homozygous dominant" {phenotype:p};
        s2: Strain s2.finalConclusion=="" && s2.phenotype == p && s2.partialConclusions.includes("homozygous");
    }
    then{
        modify(s2, "finalConclusion", "homozygous dominant");
    }
}



// Rule makeInferenceFromS1xS3_HET in English
// IF there is a goal to determine the gene type of S 
// And S1’s final conclusion is Homozygous Recessive
// And the phenotype of S1 is different from the phenotype of S3
// And S3’s partial conclusion is “Heterozygous or Homozygous recessive”
// THEN
// Write S3’s final conclusion as Heterozygous
rule makeInferenceFromS1xS3_HET{
    when{
        prob: Problem prob.subgoal==="makeInferences";
        s1: Strain s1.finalConclusion==="homezygous recessive" {phenotype:p};
        s3: Strain s3.finalConclusion=="" && s3.partialConclusions.includes("homozygous recessive or heterozygous") && s3.phenotype!==p;
    }then{
        modify(s3, "finalConclusion", "heterozygous");
    }
}

//TODO makeInferenceFromTwoPartial - This rule makes inference of final conclusion when both partial conclusions has been made for one strain
// rule makeInferenceFromTwoPartial
// IF 
// there is a goal to determine the gene type of S 
// And S1 has two partial conclusion
// And S1 has no final conclusion
// THEN
// Write S1’s final conclusion as Homozygous recessive
rule makeInferenceFromTwoPartial{
    salience:-4;
    when{
        prob: Problem prob.subgoal==="makeInferences" {strains: s};
        s1: Strain s.includes(s1.name) && s1.partialConclusions.length === 2 && s1.finalConclusion == "";
    }then{
        modify(s1, "finalConclusion", "homozygous recessive");
    }
}

// doneInferencing
// IF we have a makeInferences subgoal
// THEN move on to the enterInferences subgoal
//
rule doneInferencing {
	salience: -5;         //  critical!!
	when {
		prob: Problem prob.subgoal === "makeInferences";
	}
	then {
		modify(prob, "subgoal", "enterInferences");
		halt();
	}
}

//--------------------------------------------------------------------------------------------
//
// Rules for the enterInferences subgoal
//
// You will need to write more rules for this subgoal.
//
//--------------------------------------------------------------------------------------------
rule enterHR{
    when{
        prob: Problem prob.subgoal==="enterInferences" {strains: s};
        s1: Strain s.includes(s1.name) && s1.finalConclusion==="homozygous recessive" && s1.finalConclusionWritten === false {finalConclusion: f, ieFinalConclusion: ie};
    }then{
        if(checkSAI({selection: ie, action: "UpdateComboBox", input: f})){
            modify(s1, "finalConclusionWritten", true);
            modify(prob, "subgoal", "makeInferences");
            //halt();
        }else{
            backtrack();
        }
    }
}

rule enterHD{
    when{
        prob: Problem prob.subgoal==="enterInferences" {strains: s};
        s1: Strain s.includes(s1.name) && s1.finalConclusion==="homozygous dominant" && s1.finalConclusionWritten === false {finalConclusion: f, ieFinalConclusion: ie};
    }then{
        if(checkSAI({selection: ie, action: "UpdateComboBox", input: f})){
            modify(s1, "finalConclusionWritten", true);
            modify(prob, "subgoal", "makeInferences");
        }else{
            backtrack();
        }
    }
}

rule enterHET{
    when{
        prob: Problem prob.subgoal==="enterInferences" {strains: s};
        s1: Strain s.includes(s1.name) && s1.finalConclusion==="heterozygous" && s1.finalConclusionWritten === false {finalConclusion: f, ieFinalConclusion: ie};
    }then{
        if(checkSAI({selection: ie, action: "UpdateComboBox", input: f})){
            modify(s1, "finalConclusionWritten", true);
            modify(prob, "subgoal", "makeInferences");
        }else{
            backtrack();
        }
    }
}

rule enterPartialH{
    when{
        prob: Problem prob.subgoal==="enterInferences" {strains: s};
        s1: Strain s.includes(s1.name) && s1.partialConclusions.includes("homozygous") && s1.partialConclusionWritten === false && s1.finalConclusion == "" {partialConclusions: p, iePartialConclusions: ie};
    }then{
        if(checkSAI({selection: ie, action: "UpdateComboBox", input: "homozygous"})){
            modify(s1, "partialConclusionWritten", true);
            modify(prob, "subgoal", "makeInferences");
        }else{
            backtrack();
        }
    }
}

rule enterPartialHETOrHR{
    when{
        prob: Problem prob.subgoal==="enterInferences" {strains: s};
        s1: Strain s.includes(s1.name) && s1.partialConclusions.includes("homozygous recessive or heterozygous") && s1.partialConclusionWritten === false && s1.finalConclusion == "" {partialConclusions: p, iePartialConclusions: ie};
    }then{
        if(checkSAI({selection: ie, action: "UpdateComboBox", input: "homozygous recessive or heterozygous"})){
            modify(s1, "partialConclusionWritten", true);
            modify(prob, "subgoal", "makeInferences");
        }else{
            backtrack();
        }
    }
}
//rule enterInference_partial{
//    when{
//        prob: Problem prob.subgoal === "enterInferences";
//        s1: Strain  (s1.partialConclusions!==[] && s1.partialConclusionWritten === false)
//          {partialConclusions: pC, iePartialConclusions: ieP};
//    }
//    then{
//        if(checkSAI({selection: ieP, action: "UpdateComboBox", input: pC},
//        function(studentSAI, tutorSAI){
//            console.log("student input: " + studentSAI.input + " | tutor expects: " + tutorSAI.input);
//            let ret = (tutorSAI.input.includes(studentSAI.input));
//            console.log("SAI Match result: " + ret);
//            return ret;
//        }
//        )){
//            modify(s1, "partialConclusionWritten", true);
//            halt();
//        }else{
//            backtrack();
//        }
//    }
//}
//
// rule enterInference_final{
//    when{
//        prob: Problem prob.subgoal === "enterInferences";
//        s1: Strain s1.finalConclusion!=="" && s1.finalConclusionWritten == false
//          {partialConclusions: pC, iePartialConclusions: ieP, finalConclusion: fC,ieFinalConclusion: ieF};
//    }
//    then{
//        if(checkSAI({selection: ieF, action: "UpdateComboBox", input: fC})){
//            modify(s1, "finalConclusionWritten", true);
//            halt();
//        }else{
//            backtrack();
//        }
//    }
//}


rule doneWithMandatoryInput {
	when {
		prob: Problem prob.subgoal === "enterInferences";
		not(s: Strain s.finalConclusion && !s.finalConclusionWritten);
		not(s: Strain s.partialConclusions.length > 0 && !s.partialConclusionWritten && !s.finalConclusionWritten);
	}
	then {
		modify(prob, "subgoal", "selectCross");
	}
}


//--------------------------------------------------------------------------------------------
//
// Done rule
//
// You will need to write a done rule.
//
//--------------------------------------------------------------------------------------------
//TODO Done rule
rule done{
    when{
        prob: Problem {strains: s};
        s1: Strain s1.n===1 && s1.finalConclusionWritten===true;
        s2: Strain s2.n===2 && s2.finalConclusionWritten===true;
        s3: Strain s3.n===3 && s3.finalConclusionWritten===true;
    }then{
        if(checkSAI({selection: "done", action: "ButtonPressed", input:"don't_care"})){
            halt();
        }
    }
}
// Note: Should the done rule test for a specific subgoal?  Which subgoal?

